@startuml
title EasySave v1.0 - Diagramme de classes


' =========================================================
' EasySave v1.0 - UML adapté livrable 1
' Objectifs:
' - BackupJob = définition (pas d’exécution)
' - Exécution portée par BackupEngine
' - Etat temps réel = fichier unique contenant tous les jobs
' - Log = journalier, temps réel, actions (transfert + création dossier)
' - Limite 5 jobs + stockage (mémoire ou JSON) via repository
' - CLI parsing 1-3 / 1;3 / espaces
' =========================================================

' ===================== Core (Domain) =====================
package "Core (Domain)" as CORE {
  enum BackupType {
    Complete
    Differential
  }

  class BackupJob {
    - id : int
    - name : String
    - source : String
    - destination : String
    - type : BackupType
  }
}

' ===================== Application (Use cases) =====================
package "Application" as APP {
  class BackupAppService {
    - repo : Persistence.IBackupJobRepository
    - engine : Backup.BackupEngine
    - ui : UI.IUI
    - parser : CLI.CommandLineParser
    + RunInteractive() : void
    + RunFromArgs(args : String[]) : void
    + CreateJob(name : String, source : String, destination : String, type : CORE.BackupType) : void
    + RemoveJob(id : int) : void
    + RunJobById(id : int) : void
    + RunJob(job : CORE.BackupJob) : void
    + RunJobsByIds(ids : int[]) : void
    + RunAllJobs() : void
  }
}

' ===================== UI (Console) =====================
package "UI (Console)" as UI {
  interface IUI {
    + ShowMessage(key : String) : void
    + ShowError(key : String) : void
    + AskString(key : String) : String
    + AskInt(key : String) : int
    + AskBackupType(key : String) : CORE.BackupType
  }

  class ConsoleUI
  IUI <|.. ConsoleUI
}

' ===================== Localization =====================
package "Localization" as LOC {
  interface ILocalizationService {
    + Get(key : String) : String
  }

  class LocalizationService {
    - culture : String
    + SetCulture(culture : String) : void
    + Get(key : String) : String
  }

  ILocalizationService <|.. LocalizationService
}

UI.ConsoleUI --> LOC.ILocalizationService

' ===================== CLI =====================
package "CLI" as CLI {
  class CommandLineParser {
    + Parse(args : String[]) : int[]
  }
}

' ===================== Persistence (Jobs) =====================
package "Persistence" as Persistence {
  interface IBackupJobRepository {
    + Add(job : CORE.BackupJob) : void
    + Remove(id : int) : void
    + GetById(id : int) : CORE.BackupJob
    + GetAll() : List<CORE.BackupJob>
    + Count() : int
    + MaxJobs() : int
  }

  interface IJobIdProvider {
    + NextId(existing : List<CORE.BackupJob>) : int
  }

  class SequentialJobIdProvider {
    + NextId(existing : List<CORE.BackupJob>) : int
  }

  class InMemoryBackupJobRepository {
    - maxJobs : int = 5
    - jobs : Dictionary<int, CORE.BackupJob>
    - idProvider : IJobIdProvider
    + Add(job : CORE.BackupJob) : void
    + Remove(id : int) : void
    + GetById(id : int) : CORE.BackupJob
    + GetAll() : List<CORE.BackupJob>
    + Count() : int
    + MaxJobs() : int
  }

  IBackupJobRepository <|.. InMemoryBackupJobRepository
  IJobIdProvider <|.. SequentialJobIdProvider

  ' Optionnel v1 mais très utile en prod: persistance JSON des jobs
  class JsonBackupJobRepository {
    - maxJobs : int = 5
    - pathProvider : CFG.IPathProvider
    - idProvider : IJobIdProvider
    - jsonOptions : JsonSerializerOptions
    + Add(job : CORE.BackupJob) : void
    + Remove(id : int) : void
    + GetById(id : int) : CORE.BackupJob
    + GetAll() : List<CORE.BackupJob>
    + Count() : int
    + MaxJobs() : int
    - Load() : List<CORE.BackupJob>
    - Save(all : List<CORE.BackupJob>) : void
  }

  IBackupJobRepository <|.. JsonBackupJobRepository
}

' ===================== Configuration (Paths) =====================
package "Configuration (Paths)" as CFG {
  interface IPathProvider {
    + GetDailyLogPath(date : DateTime) : String
    + GetStatePath() : String
    + GetJobsConfigPath() : String
  }

  class DefaultPathProvider
  IPathProvider <|.. DefaultPathProvider
}

' ===================== Backup (Execution) =====================
package "Backup (Execution)" as Backup {

  class BackupEngine {
    - fileSystem : SystemAbstractions.IFileSystem
    - transferService : SystemAbstractions.ITransferService
    - stateWriter : ETR.IStateWriter
    - logger : EasyLog.ILogger
    + Execute(job : CORE.BackupJob) : void
    + CanCopyFile(type : BackupType, sourceFile : string, destinationFile : string) : bool
  }
}

' ===================== System Abstractions =====================
package "SystemAbstractions" as SystemAbstractions {

  ' ---------- Interfaces ----------
  interface IFileSystem {
    + DirectoryExists(path : String) : bool
    + CreateDirectory(path : String) : void
    + FileExists(path : String) : bool
    + GetFileSize(path : String) : long
    + CopyFile(src : String, dst : String) : void
    + EnsureDirectoryForFileExists(filePath : String) : void
    + EnumerateFilesRecursive(rootPath : String) : IEnumerable<string>
    + EnumerateDirectoriesRecursive(rootPath : String) : IEnumerable<string>
    + Combine(parts : params string[]) : string
    + NormalizePath(path : string) : string
    + GetRelativePath(rootPath : string, fullPath : string) : string
  }

  interface ITransferService {
    + TransferFile(
        sourcePath : string,
        destinationPath : string,
        overwrite : bool
      ) : TransferResult
  }

  ' ---------- Implementations ----------
  class DefaultFileSystem
  class DefaultTransferService {
    - fileSystem : IFileSystem
  }

  IFileSystem <|.. DefaultFileSystem
  ITransferService <|.. DefaultTransferService

  ' ---------- Transfer Result ----------
  class TransferResult <<record, sealed>> {
    - FileSizeBytes : long
    - TransferTimeMs : long
    - ErrorCode : int

    + IsSuccess : bool
    --
    + InvalidSourcePath() : TransferResult
    + InvalidDestinationPath() : TransferResult
  }

  class ErrorCodes <<static>> {
    + None : int = 0
    + InvalidSourcePath : int = -1
    + InvalidDestinationPath : int = -2
    + SourceNotFound : int = -3
  }

  TransferResult *-- ErrorCodes
}
' ===================== EasyLog.dll (Journalier) =====================
package "EasyLog.dll" as EasyLog {
  enum LogEventType {
    CreateDirectory
    TransferFile
    Error
  }

  class LogEntry {
    + timestamp : DateTime
    + backupName : String
    + eventType : LogEventType
    + sourcePathUNC : String
    + destinationPathUNC : String
    + fileSizeBytes : long
    + transferTimeMs : long
  }

  interface ILogger {
    + Write(entry : LogEntry) : void
  }

  interface ILogFormatter {
    + Format(entry : LogEntry) : String
  }

  class JsonLogFormatter {
    + Format(entry : LogEntry) : String
  }

  class DailyFileLogger {
    - formatter : ILogFormatter
    - pathProvider : CFG.IPathProvider
    + Write(entry : LogEntry) : void
    + Dispose() : void
    - NormalizeEntry(e : LogEntry) : static NormalizeEntry
    - NormalizePath(path : string) : static string
    - EnsureDirectoryExists(filePath : string) : static void
    - AppendJsonObjectToArrayFile(path : string, jsonObject : string) : static void
    - IndentBlock(text : string, spaces : int) : static string
  }

  ILogger <|.. DailyFileLogger
  ILogFormatter <|.. JsonLogFormatter
  DailyFileLogger --> ILogFormatter
}

' ===================== ETR (Etat Temps Réel - fichier unique) =====================
package "ETR (Etat Temps Réel)" as ETR {
  class StateEntry {
    + backupId : int
    + backupName : String
    + timestamp : DateTime
    + status : ETR.BackupStatus
    + totalFiles : int
    + totalSizeBytes : long
    + remainingFiles : int
    + remainingSizeBytes : long
    + progressPercent : int
    + currentSourcePath : String
    + currentDestinationPath : String
  }

  enum BackupStatus {
    Inactive
    Active
    Done
    Error
  }

  class GlobalState {
    + updatedAt : DateTime
    + entries : Dictionary<int, StateEntry>
  }

  interface IStateWriter {
    + Update(entry : StateEntry) : void
    + MarkInactive(backupId : int) : void
  }

  class StateSerializer {
    + ToPrettyJson(path : String, state : GlobalState) : void
  }

  class RealTimeStateWriter {
    - pathProvider : CFG.IPathProvider
    - state : GlobalState
    + Update(entry : StateEntry) : void
    + MarkInactive(backupId : int) : void
  }

  IStateWriter <|.. RealTimeStateWriter
  RealTimeStateWriter --> StateSerializer
}

' ===================== Cross-package wiring =====================
APP.BackupAppService --> Persistence.IBackupJobRepository
APP.BackupAppService --> Backup.BackupEngine
APP.BackupAppService --> UI.IUI
APP.BackupAppService --> CLI.CommandLineParser

Backup.BackupEngine --> SystemAbstractions.IFileSystem
Backup.BackupEngine --> SystemAbstractions.ITransferService
Backup.BackupEngine --> ETR.IStateWriter
Backup.BackupEngine --> EasyLog.ILogger
TransferResult --> DefaultTransferService

Persistence.JsonBackupJobRepository --> CFG.IPathProvider
EasyLog.DailyFileLogger --> CFG.IPathProvider
ETR.RealTimeStateWriter --> CFG.IPathProvider
@enduml
